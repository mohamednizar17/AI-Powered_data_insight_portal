<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI-Powered Data Insight Portal</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap');
    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background: #f9f7f3;
      color: #1f2937;
      line-height: 1.6;
      overflow-x: hidden;
    }
    header {
      background: #0d6d64;
      color: #ffffff;
      padding: 1.5rem;
      text-align: center;
      font-size: 2rem;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .container {
      display: flex;
      justify-content: center;
      margin: 2rem auto;
      gap: 1.5rem;
      padding: 0 1.5rem;
      max-width: 1200px;
    }
    .section {
      max-width: 1000px;
      margin: 2rem auto;
      padding: 2rem;
      background: #f1f5f9;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      display: none;
    }
    h2 {
      margin: 0 0 1rem;
      color: #0d6d64;
      font-size: 1.6rem;
      font-weight: 600;
    }
    label {
      font-weight: 500;
      display: block;
      margin: 1rem 0 0.5rem;
      color: #0d6d64;
    }
    input[type="color"], input[type="file"], input[type="number"], select {
      width: 100%;
      padding: 0.8rem;
      margin: 0.5rem 0;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      background-color: #ffffff;
      color: #1f2937;
      font-size: 0.95rem;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    input:focus, select:focus {
      border-color: #0d6d64;
      outline: none;
      box-shadow: 0 0 0 3px rgba(13, 109, 100, 0.15);
    }
    .checkbox-group, .radio-group {
      margin: 1rem 0;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .checkbox-group label, .radio-group label {
      background-color: #e2e8f0;
      border-radius: 8px;
      padding: 0.6rem 1.2rem;
      color: #0d6d64;
      font-weight: 400;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
    }
    .checkbox-group label:hover, .radio-group label:hover {
      background-color: #ccfbf1;
      transform: translateY(-1px);
    }
    button {
      margin: 1rem 0.5rem 0 0;
      padding: 0.8rem 1.8rem;
      border: none;
      background: #0d6d64;
      color: #ffffff;
      font-weight: 500;
      font-size: 0.95rem;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      min-width: 140px;
    }
    button:hover:not(:disabled) {
      background: #0b5b53;
      transform: translateY(-2px);
    }
    button:disabled {
      background: #94a3b8;
      cursor: not-allowed;
    }
    canvas {
      margin: 2rem 0;
      width: 100% !important;
      max-height: 500px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    }
    .legend-box, .ai-suggestions {
      margin: 1.5rem 0;
      padding: 1.5rem;
      background: #e2e8f0;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      font-size: 1rem;
    }
    .ai-suggestions ul {
      margin: 0.5rem 0 0;
      padding-left: 1.5rem;
    }
    .ai-suggestions h3 {
      margin: 0.5rem 0;
      font-size: 1.1rem;
      color: #0d6d64;
    }
    .ai-help {
      font-size: 0.9rem;
      color: #4b5563;
      margin: 0.3rem 0 0;
      font-style: italic;
    }
    .loading {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    .loading::after {
      content: '';
      width: 16px;
      height: 16px;
      border: 2px solid #ffffff;
      border-top: 2px solid transparent;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    .feedback {
      margin: 0.75rem 0 0;
      font-size: 0.9rem;
      color: #dc2626;
    }
    .feedback.success {
      color: #0d6d64;
    }
    /* Home Page Styles */
    #homeSection {
      position: relative;
      min-height: 80vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 3rem 1.5rem;
      overflow: hidden;
    }
    .home-box {
      background: #ffffff;
      padding: 2rem;
      border-radius: 12px;
      font-size: 1.5rem;
      font-weight: 500;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 12px rgba(13, 109, 100, 0.1);
      max-width: 400px;
      width: 100%;
    }
    .home-box:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(13, 109, 100, 0.2);
    }
    .tagline {
      margin: 1.5rem 0 0;
      font-size: 1.2rem;
      color: #0d6d64;
      font-weight: 400;
      max-width: 600px;
    }
    .canvas-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.1;
    }
    .data-icon {
      position: absolute;
      font-size: 2rem;
      color: #0d6d64;
      opacity: 0.3;
      transition: transform 0.3s, opacity 0.3s;
      cursor: pointer;
    }
    .data-icon:hover {
      transform: scale(1.2);
      opacity: 0.6;
    }
    /* Main Section Box Styles */
    .box {
      flex: 1;
      background: #f1f5f9;
      padding: 1.5rem;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      font-weight: 500;
      font-size: 1.1rem;
      position: relative;
      overflow: hidden;
      transition: transform 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
      border: 1px solid #e2e8f0;
    }
    .box:hover {
      transform: scale(1.05);
      background-color: #ccfbf1;
      box-shadow: 0 6px 16px rgba(13, 109, 100, 0.2);
    }
    .box.prep:hover::before {
      content: '‚öôÔ∏è';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(0deg);
      font-size: 2rem;
      color: #0d6d64;
      opacity: 0.2;
      animation: rotateGear 2s linear infinite;
    }
    .box.viz:hover::before {
      content: 'üìä';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      color: #0d6d64;
      opacity: 0.2;
      animation: pulseChart 1.5s ease-in-out infinite;
    }
    @keyframes float {
      0% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
      100% { transform: translateY(0); }
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    @keyframes rotateGear {
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }
    @keyframes pulseChart {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.2; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.4; }
    }
    :focus-visible {
      outline: 3px solid #0d6d64;
      outline-offset: 2px;
    }
    @media (max-width: 768px) {
      header {
        font-size: 1.5rem;
        padding: 1rem;
      }
      .container {
        flex-direction: column;
        padding: 0 1rem;
      }
      .section {
        margin: 1rem;
        padding: 1.5rem;
      }
      .home-box {
        padding: 1.5rem;
        font-size: 1.2rem;
      }
      .tagline {
        font-size: 1rem;
      }
      button {
        width: 100%;
        margin: 0.5rem 0;
      }
      .box {
        padding: 1rem;
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <header>AI-Powered Data Insight Portal</header>

  <!-- Home Page -->
  <div id="homeSection" class="container">
    <div class="home-box" onclick="document.getElementById('fileInput').click()">Upload Your Data</div>
    <p class="tagline">Discover fun insights with AI-powered visualizations! üìà</p>
    <canvas id="bgCanvas" class="canvas-bg"></canvas>
    <span class="data-icon" style="top: 20%; left: 10%;" title="Bar Chart">üìä</span>
    <span class="data-icon" style="top: 30%; right: 15%;" title="Pie Chart">ü•ß</span>
    <span class="data-icon" style="bottom: 25%; left: 20%;" title="Data Points">üìç</span>
    <span class="data-icon" style="bottom: 20%; right: 10%;" title="CSV File">üìÑ</span>
  </div>
  <input type="file" accept=".csv" id="fileInput" style="display:none" />

  <!-- Main Choice Page -->
  <div id="mainSection" class="section">
    <div class="container">
      <div class="box prep" onclick="showSection('prepSection')">Data Preparation</div>
      <div class="box viz" onclick="checkPreparationBeforeViz()">Data Visualization</div>
    </div>
  </div>

  <!-- Data Preparation Page -->
  <div id="prepSection" class="section">
    <h2>Data Preparation</h2>
    <div id="aiSuggestions" class="ai-suggestions"></div>
    <label>Missing Value Handling (Numerical Columns)</label>
    <div class="ai-help">AI: Mean for stable distributions, median for skewed data.</div>
    <select id="missingValueAction">
      <option value="none">None</option>
      <option value="mean">Fill with Mean (AI Suggested)</option>
      <option value="median">Fill with Median</option>
      <option value="remove">Remove Rows</option>
    </select>
    <label>Outlier Handling (Numerical Columns)</label>
    <div class="ai-help">AI: Cap to retain rows, remove for cleaner data.</div>
    <select id="outlierAction">
      <option value="none">None</option>
      <option value="remove">Remove Outliers</option>
      <option value="cap">Cap Outliers (AI Suggested)</option>
    </select>
    <label>Missing Value Handling (Categorical Columns)</label>
    <div class="ai-help">AI: Mode fill to preserve patterns or remove rows.</div>
    <select id="categoricalMissingAction">
      <option value="none">None</option>
      <option value="mode">Fill with Mode (AI Suggested)</option>
      <option value="remove">Remove Rows</option>
    </select>
    <label>Normalize Numerical Columns</label>
    <div class="ai-help">AI: Normalize high-variance columns for scaling.</div>
    <div id="normalizeCheckboxes" class="checkbox-group"></div>
    <button id="applyPrepBtn" onclick="applyPreparation()">Apply Preparation</button>
    <button id="downloadDataBtn" onclick="downloadTransformedData()">Download Transformed Data</button>
    <div id="prepFeedback" class="feedback"></div>
    <button onclick="showSection('vizSection')">Proceed to Visualization</button>
  </div>

  <!-- Data Visualization Page -->
  <div id="vizSection" class="section">
    <h2>Data Visualization</h2>
    <div id="aiVizSuggestions" class="ai-suggestions"></div>
    <label>Start Index</label>
    <div class="ai-help">AI: Focus on a specific data subset.</div>
    <input type="number" id="startIndex" value="0" min="0" onchange="validateInputs()" />
    <label>End Index</label>
    <div class="ai-help">AI: Include all relevant data points.</div>
    <input type="number" id="endIndex" min="1" onchange="validateInputs()" />
    <label>Choose X-axis Column</label>
    <div class="ai-help">AI: Categorical for bar/pie, numerical for scatter.</div>
    <div id="xAxisRadios" class="radio-group"></div>
    <label>Choose Y-axis Columns</label>
    <div class="ai-help">AI: Numerical columns; multiple for stacked/radar.</div>
    <div id="yAxisCheckboxes" class="checkbox-group"></div>
    <label for="bubbleSizeSelect">Bubble Chart Size Column</label>
    <div class="ai-help">AI: Numerical column for bubble sizes.</div>
    <select id="bubbleSizeSelect"></select>
    <label>Choose Color</label>
    <div class="ai-help">AI: High contrast for clarity.</div>
    <input type="color" id="colorPicker" value="#0d6d64" />
    <label>Select Plot Type</label>
    <div class="ai-help">AI: Bar for categorical-numerical, scatter for numerical.</div>
    <select id="plotType">
      <option value="bar">Bar Chart</option>
      <option value="scatter">Scatter Plot</option>
      <option value="line">Line Chart</option>
      <option value="pie">Pie Chart</option>
      <option value="bubble">Bubble Chart</option>
      <option value="area">Area Chart</option>
      <option value="stacked">Stacked Bar Chart</option>
      <option value="histogram">Histogram</option>
      <option value="doughnut">Doughnut Chart</option>
      <option value="radar">Radar Chart</option>
    </select>
    <button id="plotBtn" onclick="plotData()">Generate Plot</button>
    <button id="downloadChartBtn" onclick="downloadChart()">Download Plot as PNG</button>
    <div id="vizFeedback" class="feedback"></div>
    <canvas id="plotCanvas"></canvas>
    <div class="legend-box" id="legendContent"></div>
    <button onclick="showSection('prepSection')">Back to Data Preparation</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    let globalData = [];
    let headers = [];
    let originalData = [];
    let numericCols = [];
    let categoricalCols = [];
    let dataProcessed = false;
    let chartInstance = null;

    // Home page background animation
    function initBackgroundAnimation() {
      const canvas = document.getElementById('bgCanvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const particles = [];
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 5 + 2,
          speedX: (Math.random() - 0.5) * 0.5,
          speedY: (Math.random() - 0.5) * 0.5
        });
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(13, 109, 100, 0.2)';
        particles.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
          p.x += p.speedX;
          p.y += p.speedY;
          if (p.x < 0 || p.x > canvas.width) p.speedX *= -1;
          if (p.y < 0 || p.y > canvas.height) p.speedY *= -1;
        });
        requestAnimationFrame(animate);
      }
      animate();

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    }
    initBackgroundAnimation();

    // Show section
    function showSection(sectionId) {
      document.querySelectorAll('.section').forEach(el => el.style.display = 'none');
      document.getElementById(sectionId).style.display = 'block';
      if (sectionId === 'vizSection') validateInputs();
    }

    // Set feedback
    function setFeedback(id, message, success = false) {
      const el = document.getElementById(id);
      el.textContent = message;
      el.classList.toggle('success', success);
    }

    // Safe float parsing
    function safeParseFloat(value) {
      if (value === null || value === '' || value === undefined) return null;
      const parsed = parseFloat(value);
      return isNaN(parsed) || !isFinite(parsed) ? null : parsed;
    }

    // Check preparation before visualization
    function checkPreparationBeforeViz() {
      if (!dataProcessed && globalData.length) {
        if (confirm('AI Warning: Data preparation not applied. Proceed to visualization?')) {
          showSection('vizSection');
        }
      } else {
        showSection('vizSection');
      }
    }

    // Validate inputs
    function validateInputs() {
      const start = parseInt(document.getElementById('startIndex').value);
      const end = parseInt(document.getElementById('endIndex').value);
      const plotBtn = document.getElementById('plotBtn');
      if (isNaN(start) || isNaN(end) || start < 0 || end > globalData.length || start >= end) {
        setFeedback('vizFeedback', 'AI: Invalid start/end indices (start < end ‚â§ data length).', false);
        plotBtn.disabled = true;
      } else {
        setFeedback('vizFeedback', '');
        plotBtn.disabled = false;
      }
    }

    // File upload handler
    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) {
        setFeedback('prepFeedback', 'No file selected.', false);
        return;
      }
      const applyBtn = document.getElementById('applyPrepBtn');
      applyBtn.disabled = true;
      applyBtn.classList.add('loading');
      setFeedback('prepFeedback', 'Uploading file...');
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          if (results.errors.length) {
            setFeedback('prepFeedback', 'Error parsing CSV: ' + results.errors[0].message, false);
            applyBtn.disabled = false;
            applyBtn.classList.remove('loading');
            return;
          }
          globalData = results.data;
          originalData = JSON.parse(JSON.stringify(globalData));
          headers = Object.keys(globalData[0] || {});
          if (!headers.length) {
            setFeedback('prepFeedback', 'No valid data in file.', false);
            applyBtn.disabled = false;
            applyBtn.classList.remove('loading');
            return;
          }
          numericCols = headers.filter(h => globalData.every(row => row[h] === null || row[h] === '' || safeParseFloat(row[h]) !== null));
          categoricalCols = headers.filter(h => !numericCols.includes(h));
          dataProcessed = false;
          analyzeData();
          populateSelectors();
          document.getElementById('endIndex').value = globalData.length;
          document.getElementById('homeSection').style.display = 'none';
          showSection('mainSection');
          applyBtn.disabled = false;
          applyBtn.classList.remove('loading');
          setFeedback('prepFeedback', 'File uploaded successfully.', true);
        },
        error: (error) => {
          setFeedback('prepFeedback', 'File parsing failed: ' + error.message, false);
          applyBtn.disabled = false;
          applyBtn.classList.remove('loading');
        }
      });
    });

    // Analyze data
    function analyzeData() {
      if (dataProcessed) {
        const hasIssues = headers.some(h => {
          if (globalData.filter(row => row[h] === null || row[h] === '').length) return true;
          if (numericCols.includes(h)) {
            const values = globalData.map(row => safeParseFloat(row[h])).filter(v => v !== null);
            const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
            const std = Math.sqrt(values.reduce((sum, v) => sum + (v - mean) ** 2, 0) / values.length);
            return values.some(v => Math.abs(v - mean) > 3 * std);
          }
          return false;
        });
        if (!hasIssues) {
          document.getElementById('aiSuggestions').innerHTML = '<strong>AI Analysis:</strong> All data issues resolved. Ready for visualization.';
          return;
        }
      }

      let suggestions = `<strong>AI Data Analysis:</strong>`;
      suggestions += `<h3>Numerical Columns</h3><ul>`;
      numericCols.forEach(h => {
        const values = globalData.map(row => safeParseFloat(row[h])).filter(v => v !== null);
        const missing = globalData.filter(row => row[h] === null || row[h] === '').length;
        const mean = values.length ? values.reduce((sum, v) => sum + v, 0) / values.length : 0;
        const std = values.length ? Math.sqrt(values.reduce((sum, v) => sum + (v - mean) ** 2, 0) / values.length) : 0;
        const outliers = values.filter(v => Math.abs(v - mean) > 3 * std).length;
        suggestions += `<li><strong>${h}</strong>: ${missing} missing value${missing === 1 ? '' : 's'}. Suggest ${std > 1 ? 'median' : 'mean'} fill.</li>`;
        suggestions += `<li><strong>${h}</strong>: ${outliers} outlier${outliers === 1 ? '' : 's'}. Suggest ${outliers > values.length * 0.1 ? 'removing' : 'capping'}.</li>`;
        suggestions += `<li><strong>${h}</strong>: ${std > 1 ? 'High variance; normalize recommended.' : 'Low variance; normalization optional.'}</li>`;
      });
      suggestions += `</ul><h3>Categorical Columns</h3><ul>`;
      categoricalCols.forEach(h => {
        const missing = globalData.filter(row => row[h] === null || row[h] === '').length;
        suggestions += `<li><strong>${h}</strong>: ${missing} missing value${missing === 1 ? '' : 's'}. Suggest mode fill or remove rows.</li>`;
      });
      suggestions += `</ul>`;
      document.getElementById('aiSuggestions').innerHTML = suggestions;

      let vizSuggestions = `<strong>AI Visualization Suggestions:</strong><ul>`;
      if (numericCols.length >= 2) vizSuggestions += `<li>Scatter/Bubble for ${numericCols[0]} vs ${numericCols[1]}.</li>`;
      if (categoricalCols.length && numericCols.length) vizSuggestions += `<li>Bar/Pie/Doughnut for ${categoricalCols[0]} vs ${numericCols[0]}.</li>`;
      if (numericCols.length) vizSuggestions += `<li>Histogram for ${numericCols[0]} distribution.</li>`;
      if (categoricalCols.length > 1) vizSuggestions += `<li>Stacked Bar for ${categoricalCols[0]} vs ${categoricalCols[1]}.</li>`;
      if (numericCols.length >= 2 && categoricalCols.length) vizSuggestions += `<li>Radar for ${numericCols[0]}/${numericCols[1]} by ${categoricalCols[0]}.</li>`;
      if (numericCols.length) {
        const range = globalData.map(row => safeParseFloat(row[numericCols[0]])).filter(v => v !== null);
        vizSuggestions += `<li>Axis range for ${numericCols[0]}: ${Math.min(...range).toFixed(1)} to ${Math.max(...range).toFixed(1)}.</li>`;
      }
      vizSuggestions += `</ul>`;
      document.getElementById('aiVizSuggestions').innerHTML = vizSuggestions;

      if (categoricalCols.length) {
        const input = document.querySelector(`input[name="xCol"][value="${categoricalCols[0]}"]`);
        if (input) input.checked = true;
      }
      if (numericCols.length) {
        const input = document.querySelector(`input[name="yCol"][value="${numericCols[0]}"]`);
        if (input) input.checked = true;
      }
    }

    // Populate selectors
    function populateSelectors() {
      const xBox = document.getElementById('xAxisRadios');
      const yBox = document.getElementById('yAxisCheckboxes');
      const bubbleSel = document.getElementById('bubbleSizeSelect');
      const normBox = document.getElementById('normalizeCheckboxes');
      xBox.innerHTML = yBox.innerHTML = normBox.innerHTML = '';
      bubbleSel.innerHTML = '<option value="" selected disabled>Select a column</option>';

      headers.forEach(h => {
        xBox.innerHTML += `<label><input type="radio" name="xCol" value="${h}"> ${h}</label>`;
        yBox.innerHTML += `<label><input type="checkbox" name="yCol" value="${h}"> ${h}</label>`;
        if (numericCols.includes(h)) {
          bubbleSel.innerHTML += `<option value="${h}">${h}</option>`;
          normBox.innerHTML += `<label><input type="checkbox" name="normCol" value="${h}"> ${h}</label>`;
        }
      });
    }

    // Apply preparation
    function applyPreparation() {
      if (!globalData.length) {
        setFeedback('prepFeedback', 'No data to process.', false);
        return;
      }
      const applyBtn = document.getElementById('applyPrepBtn');
      applyBtn.disabled = true;
      applyBtn.classList.add('loading');
      setFeedback('prepFeedback', 'Applying preparation...');

      globalData = JSON.parse(JSON.stringify(originalData));
      const missingAction = document.getElementById('missingValueAction').value;
      const outlierAction = document.getElementById('outlierAction').value;
      const catMissingAction = document.getElementById('categoricalMissingAction').value;
      const normCols = Array.from(document.querySelectorAll('input[name="normCol"]:checked')).map(el => el.value);

      numericCols.forEach(h => {
        const values = globalData.map(row => safeParseFloat(row[h])).filter(v => v !== null);
        const mean = values.length ? values.reduce((sum, v) => sum + v, 0) / values.length : 0;
        const median = values.length ? values.sort((a, b) => a - b)[Math.floor(values.length / 2)] : 0;
        const std = values.length ? Math.sqrt(values.reduce((sum, v) => sum + (v - mean) ** 2, 0) / values.length) : 0;

        if (missingAction === 'mean') {
          globalData.forEach(row => { if (row[h] === null || row[h] === '') row[h] = mean.toFixed(2); });
        } else if (missingAction === 'median') {
          globalData.forEach(row => { if (row[h] === null || row[h] === '') row[h] = median.toFixed(2); });
        } else if (missingAction === 'remove') {
          globalData = globalData.filter(row => row[h] !== null && row[h] !== '');
        }

        if (outlierAction === 'remove') {
          globalData = globalData.filter(row => {
            const v = safeParse(row[h]);
            return v === null || Math.abs(v - mean) <= 3 * std;
          });
        } else if (outlierAction === 'cap') {
          globalData.forEach(row => {
            const v = safeParseFloat(row[h]);
            if (v !== null) {
              if (v > mean + 3 * std) row[h] = (mean + 1 * std).toString();
              if (v < mean - 3 * std) row[h] = (mean - 1 * std).toString();
            }
          });
        }

        if (normCols.includes(h) && values.length) {
          const min = Math.min(...values);
          const max = Math.max(...values);
          if (max !== min) {
            globalData.forEach(row => {
              const v = safeParseFloat(row[h]);
              if (v !== null) row[h] = ((v - min) / (max - min)).toFixed(2);
            });
          }
        }
      });

      if (catMissingAction === 'mode') {
        categoricalCols.forEach(h => {
          const values = globalData.map(row => row[h]).filter(v => v !== null && v !== '');
          const mode = values.length ? values.reduce((a, b, i, arr) => (arr.filter(v => v === a).length >= arr.filter(v => v === b).length ? a : b)) : 'Unknown';
          globalData.forEach(row => { if (row[h] === null || row[h] === '') row[h] = mode; });
        });
      } else if (catMissingAction === 'remove') {
        categoricalCols.forEach(h => {
          globalData = globalData.filter(row => row[h] !== null && row[h] !== '');
        });
      }

      dataProcessed = true;
      document.getElementById('endIndex').value = globalData.length;
      analyzeData();
      applyBtn.disabled = false;
      applyBtn.classList.remove('loading');
      setFeedback('prepFeedback', 'Data preparation applied successfully.', true);
    }

    // Download transformed data
    async function downloadTransformedData() {
      if (!globalData.length) {
        setFeedback('prepFeedback', 'No data to download.', false);
        return;
      }
      const downloadBtn = document.getElementById('downloadDataBtn');
      downloadBtn.disabled = true;
      downloadBtn.classList.add('loading');
      setFeedback('prepFeedback', 'Downloading...');

      try {
        const csv = Papa.unparse(globalData, {
          header: true,
          quotes: true,
          delimiter: ',',
          escapeFormulae: true
        });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'transformed_data.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
        setFeedback('prepFeedback', 'Data downloaded successfully.', true);
      } catch (error) {
        setFeedback('prepFeedback', 'Error downloading data: ' + error.message, false);
      } finally {
        downloadBtn.disabled = false;
        downloadBtn.classList.remove('loading');
      }
    }

    // Download chart
    async function downloadChart() {
      const canvas = document.getElementById('plotCanvas');
      if (!canvas || !chartInstance) {
        setFeedback('vizFeedback', 'Please generate a plot first.', false);
        return;
      }
      const downloadBtn = document.getElementById('downloadChartBtn');
      downloadBtn.disabled = true;
      downloadBtn.classList.add('loading');
      setFeedback('vizFeedback', 'Downloading plot...');

      try {
        await new Promise(resolve => setTimeout(resolve, 100));
        return new Promise((resolve, reject) => {
          canvas.toBlob(blob => {
            if (!blob) {
              reject(new Error('Failed to generate image.'));
              return;
            }
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'chart.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
            setFeedback('vizFeedback', 'Plot downloaded successfully.', true);
            resolve();
          }, 'image/png', 1);
        });
      } catch (error) {
        setFeedback('vizFeedback', 'Error downloading plot: ' + error.message, false);
      } finally {
        downloadBtn.disabled = false;
        downloadBtn.classList.remove('loading');
      }
    }

    // Plot data
    async function plotData() {
      const xCol = document.querySelector('input[name="xCol"]:checked')?.value;
      const yCols = Array.from(document.querySelectorAll('input[name="yCol"]:checked')).map(el => el.value);
      let plotType = document.getElementById('plotType').value;
      const bubbleSizeCol = document.getElementById('bubbleSizeSelect').value;
      const color = document.getElementById('colorPicker').value;
      const start = parseInt(document.getElementById('startIndex').value) || 0;
      const end = parseInt(document.getElementById('endIndex').value);

      if (!xCol) {
        setFeedback('vizFeedback', 'Select one X-axis column.', false);
        return;
      }
      if (!yCols.length) {
        setFeedback('vizFeedback', 'Select at least one Y-axis column.', false);
        return;
      }
      if (start < 0 || end > globalData.length || start >= end) {
        setFeedback('vizFeedback', 'Invalid start/end indices.', false);
        return;
      }

      const plotBtn = document.getElementById('plotBtn');
      plotBtn.disabled = true;
      plotBtn.classList.add('loading');
      setFeedback('vizFeedback', 'Generating plot...');

      let suggestedScales = {};
      if (numericCols.includes(xCol)) {
        const range = globalData.map(row => safeParseFloat(row[xCol])).filter(v => v !== null);
        suggestedScales.x = { min: Math.min(...range), max: Math.max(...range) };
      }
      if (numericCols.includes(yCols[0])) {
        const range = globalData.map(row => safeParseFloat(row[yCols[0]])).filter(v => v !== null);
        suggestedScales.y = { min: Math.min(...range), max: Math.max(...range) };
      }

      if (categoricalCols.includes(xCol) && numericCols.includes(yCols[0])) {
        if (!['bar', 'pie', 'doughnut', 'stacked'].includes(plotType)) {
          plotType = 'bar';
          document.getElementById('plotType').value = 'bar';
          setFeedback('vizFeedback', 'AI: Bar chart selected for categorical X and numerical Y.', true);
        }
      } else if (numericCols.includes(xCol) && numericCols.includes(yCols[0])) {
        if (!['scatter', 'bubble', 'line'].includes(plotType)) {
          plotType = 'scatter';
          document.getElementById('plotType').value = 'scatter';
          setFeedback('vizFeedback', 'AI: Scatter plot selected for numerical X and Y.', true);
        }
      }

      const ctx = document.getElementById('plotCanvas').getContext('2d');
      if (chartInstance) chartInstance.destroy();

      const slicedData = globalData.slice(start, end);
      let config;

      try {
        if (plotType === 'bubble') {
          if (!numericCols.includes(bubbleSizeCol)) {
            throw new Error('Select a numerical column for bubble size.');
          }
          const dataPoints = slicedData.map(row => ({
            x: safeParseFloat(row[xCol]) || 0,
            y: safeParseFloat(row[yCols[0]]) || 0,
            r: Math.max((safeParseFloat(row[bubbleSizeCol]) || 0) / 5, 1)
          }));
          config = {
            type: 'bubble',
            data: {
              datasets: [{
                label: `${yCols[0]} vs ${xCol}`,
                data: dataPoints,
                backgroundColor: color + '80',
                borderColor: color,
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              scales: {
                x: { title: { display: true, text: xCol }, ...suggestedScales.x },
                y: { title: { display: true, text: yCols[0] }, ...suggestedScales.y }
              }
            }
          };
          document.getElementById('legendContent').innerHTML = '';
        } else if (plotType === 'histogram') {
          if (!numericCols.includes(yCols[0])) {
            throw new Error('Select a numerical column for histogram.');
          }
          const values = slicedData.map(row => safeParseFloat(row[yCols[0]])).filter(v => v !== null);
          if (!values.length) {
            throw new Error('No valid data for histogram.');
          }
          const min = Math.min(...values);
          const max = Math.max(...values);
          const binCount = 10;
          const binSize = (max - min) / binCount || 1;
          const bins = Array.from({ length: binCount + 1 }, (_, i) => min + i * binSize);
          const binData = Array(binCount).fill(0);
          values.forEach(v => {
            const binIndex = Math.min(Math.floor((v - min) / binSize), binCount - 1);
            binData[binIndex]++;
          });
          config = {
            type: 'bar',
            data: {
              labels: bins.slice(0, -1).map(v => v.toFixed(2)),
              datasets: [{
                label: `Histogram of ${yCols[0]}`,
                data: binData,
                backgroundColor: color,
                borderColor: color,
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              scales: {
                x: { title: { display: true, text: yCols[0] } },
                y: { title: { display: true, text: 'Count' } }
              }
            }
          };
          document.getElementById('legendContent').innerHTML = '';
        } else if (plotType === 'stacked') {
          const grouped = {};
          slicedData.forEach(row => {
            const key = row[xCol] || 'Unknown';
            if (!grouped[key]) grouped[key] = {};
            yCols.forEach(y => {
              grouped[key][y] = (grouped[key][y] || 0) + (safeParseFloat(row[y]) || 0);
            });
          });
          const labels = Object.keys(grouped);
          const datasets = yCols.map((y, i) => ({
            label: y,
            data: labels.map(k => grouped[k][y] || 0),
            backgroundColor: `hsl(${i * 60}, 70%, 60%)`,
            borderColor: `hsl(${i * 60}, 70%, 60%)`,
            borderWidth: 1
          }));
          config = {
            type: 'bar',
            data: { labels, datasets },
            options: {
              responsive: true,
              scales: {
                x: { stacked: true, title: { display: true, text: xCol } },
                y: { stacked: true, title: { display: true, text: 'Value' }, ...suggestedScales.y }
              }
            }
          };
          generateLegend(labels, grouped, yCols[0]);
        } else if (plotType === 'radar') {
          const grouped = {};
          slicedData.forEach(row => {
            const key = row[xCol] || 'Unknown';
            if (!grouped[key]) grouped[key] = {};
            yCols.forEach(y => {
              grouped[key][y] = (grouped[key][y] || 0) + (safeParseFloat(row[y]) || 0);
            });
          });
          const labels = yCols;
          const datasets = Object.keys(grouped).map((key, i) => ({
            label: key,
            data: yCols.map(y => grouped[key][y] || 0),
            backgroundColor: `hsla(${i * 60}, 70%, 50%, 0.2)`,
            borderColor: `hsl(${i * 60}, 70%, 50%)`,
            borderWidth: 1
          }));
          config = {
            type: 'radar',
            data: { labels, datasets },
            options: {
              responsive: true,
              scales: { r: { suggestedMin: 0 } }
            }
          };
          document.getElementById('legendContent').innerHTML = '';
        } else {
          const grouped = {};
          slicedData.forEach(row => {
            const key = row[xCol] || 'Unknown';
            if (!grouped[key]) grouped[key] = {};
            yCols.forEach(y => {
              grouped[key][y] = (grouped[key][y] || 0) + (safeParseFloat(row[y]) || 0);
            });
          });
          const labels = Object.keys(grouped);
          if (['pie', 'doughnut'].includes(plotType)) {
            config = {
              type: plotType,
              data: {
                labels,
                datasets: [{
                  data: labels.map(k => grouped[k][yCols[0]] || 0),
                  backgroundColor: labels.map((_, i) => `hsl(${i * 30}, 70%, 60%)`)
                }]
              },
              options: {
                responsive: true,
                plugins: { legend: { display: true } }
              }
            };
            document.getElementById('legendContent').innerHTML = '';
          } else {
            const datasets = yCols.map((y, i) => ({
              label: y,
              data: labels.map(k => grouped[k][y] || 0),
              backgroundColor: plotType === 'area' ? `hsla(${i * 60}, 70%, 60%, 0.4)` : color,
              borderColor: color,
              borderWidth: 1,
              fill: plotType === 'area'
            }));
            config = {
              type: plotType === 'area' ? 'line' : plotType,
              data: { labels, datasets },
              options: {
                responsive: true,
                scales: {
                  x: { title: { display: true, text: xCol }, ...suggestedScales.x },
                  y: { title: { display: true, text: yCols.join(', ') }, ...suggestedScales.y }
                }
              }
            };
            generateLegend(labels, grouped, yCols[0]);
          }
        }

        chartInstance = new Chart(ctx, config);
        setFeedback('vizFeedback', 'Plot generated successfully.', true);
      } catch (error) {
        setFeedback('vizFeedback', 'Error generating plot: ' + error.message, false);
      } finally {
        plotBtn.disabled = false;
        plotBtn.classList.remove('loading');
      }
    }

    // Generate legend
    function generateLegend(labels, grouped, valueKey) {
      if (!labels.length || !grouped[labels[0]][valueKey]) {
        document.getElementById('legendContent').innerHTML = '';
        return;
      }
      const total = labels.reduce((sum, k) => sum + (grouped[k][valueKey] || 0), 0);
      let html = `<strong>Legend - ${valueKey}</strong><ul>`;
      labels.forEach(k => {
        const perc = total ? ((grouped[k][valueKey] || 0) / total * 100).toFixed(1) : 0;
        html += `<li><span style="color:#0d6d64;">${k}</span>: ${perc}%</li>`;
      });
      html += `</ul>`;
      document.getElementById('legendContent').innerHTML = html;
    }
  </script>
</body>
</html>
